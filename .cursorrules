# Cursor Rules for Divemap Project

## Environment Management

### Docker Container Management
- **ALWAYS use docker to manage containers**
- **NEVER start services directly on the system**
- **ALWAYS use the following container names:**
  - `divemap_db` - MySQL database
  - `divemap_backend` - Python FastAPI backend
  - `divemap_frontend` - React frontend
- **ALWAYS use docker exec to run commands inside containers IF needed**
- **NEVER run frontend or backend commands outside of containers**
- **ALWAYS use `docker logs` for container logging (NEVER use `docker-compose logs`)**
- **ALWAYS use `docker logs --since` flag for efficient log filtering when debugging**

### Virtual Environment Requirements
- **NEVER install Python packages in the system Python**
- **ALWAYS use docker containers named divemap_db, divemap_frontend, divemap_backend to execute commands**
- **NEVER try to start frontend, backend or database on the system**
- **NEVER run npm, node, or any frontend commands on the system**
- **ALWAYS use virtual environments for Python development**
- **ALWAYS activate the virtual environment before installing packages**
- **NEVER install npm packages globally**
- **ALWAYS use project-specific node_modules**

### Python Development
```bash
# ✅ CORRECT - Always use virtual environment
cd backend
source divemap_venv/bin/activate
export PYTHONPATH="/home/kargig/src/divemap/backend/divemap_venv/lib/python3.11/site-packages:$PYTHONPATH"
pip install package_name

# ❌ WRONG - Never install in system Python
pip install package_name  # This is forbidden
```

### Node.js Development
```bash
# ✅ CORRECT - Use Docker containers for frontend development
docker-compose exec divemap_frontend npm install package_name
docker-compose exec divemap_frontend npm start
docker-compose exec divemap_frontend npm run build
docker-compose exec divemap_frontend npm run lint:fix

# ❌ WRONG - Never run npm/node on the system
npm install package_name  # This is forbidden
npm start  # This is forbidden
npm run build  # This is forbidden
npm test  # This is forbidden
```

## Database Migration Rules

### Alembic Migration Requirements
- **MUST always take a full mysql backup BEFORE any database schema changes and name it according to the latest git commit**
- **MUST use Alembic for ALL database schema changes**
- **NEVER modify database schema manually**
- **ALWAYS create migrations for schema changes**
- **ALWAYS test migrations before applying**
- **ALWAYS restore the most recent database backup when a migration script fails, and then try again with any necessary changes**

### Migration Workflow
```bash
# ✅ CORRECT - Use Alembic for migrations
cd backend
source divemap_venv/bin/activate
export PYTHONPATH="/home/kargig/src/divemap/backend/divemap_venv/lib/python3.11/site-packages:$PYTHONPATH"

# Create new migration
python create_migration.py "Description of changes"

# Run migrations
python run_migrations.py

# ❌ WRONG - Never modify database manually
# Direct SQL ALTER TABLE statements are forbidden
```

### Migration Best Practices
- Always review auto-generated migrations
- Test migrations on development database first
- Backup production database before migrations
- Use descriptive migration names
- Handle dependencies between migrations

### Migration Creation Anti-Hallucination Rule
- **BEFORE creating any new migration file, ALWAYS examine previous successful migrations**
- **ALWAYS look at the last 3-5 migration files to see which methods have worked successfully**
- **NEVER invent new migration patterns without first checking existing working examples**
- **ALWAYS use the same successful patterns from previous migrations for similar operations**
- **If a migration pattern worked before, use it again instead of trying something new**
- **When in doubt, copy the structure and approach from a similar previous migration**
- **This prevents migration creation hallucinations and ensures consistency**

### Migration Testing Requirements
- **ALWAYS test new migration files on a test MySQL container before applying to production**
- **ALWAYS use the same testing approach as the GitHub Actions workflow**
- **NEVER assume a migration will work without testing it first**
- **ALWAYS verify that the created tables match exactly what the models expect**

### Migration Testing Workflow
```bash
# ✅ CORRECT - Test migrations on isolated MySQL container
# 1. Start test MySQL container
docker run --name divemap_test_mysql \
  -e MYSQL_ROOT_PASSWORD=password \
  -e MYSQL_DATABASE=divemap_test \
  -d -p 3307:3306 mysql:8.0

# 2. Wait for MySQL to be ready
sleep 15
docker exec divemap_test_mysql mysql -u root -ppassword -e "SELECT 1;"

# 3. Set up Python environment
cd backend
source divemap_venv/bin/activate
export PYTHONPATH="/home/kargig/src/divemap/backend/divemap_venv/lib/python3.11/site-packages:$PYTHONPATH"
export DATABASE_URL="mysql+pymysql://root:password@localhost:3307/divemap_test"

# 4. Run all migrations from scratch
alembic upgrade head

# 5. Verify all modified tables in the migration file match models. Example:
docker exec divemap_test_mysql mysql -u root -ppassword divemap_test -e "DESCRIBE parsed_dive_trips;"

# 6. Run backend tests to ensure compatibility
python -m pytest tests/ -v

# 7. Clean up test container
docker stop divemap_test_mysql && docker rm divemap_test_mysql

# ❌ WRONG - Don't skip migration testing
# Never apply migrations without testing them first
# Never assume migrations will work in production
```

### Migration Testing Checklist
Before considering a migration ready for production:
- [ ] Migration runs successfully on test MySQL container
- [ ] All tables are created with correct structure
- [ ] Column types match model definitions exactly
- [ ] Indexes are created correctly
- [ ] Constraints are applied properly
- [ ] Backend tests pass with new schema
- [ ] Models can successfully query the database
- [ ] Test container is cleaned up after testing

### Migration Filename Requirements
- **MUST always use numerical ordering for migration filenames**
- **MUST follow the format: `####_descriptive_name.py` where #### is a 4-digit number**
- **MUST ensure sequential numbering (0001, 0002, 0003, etc.)**
- **MUST use descriptive names that clearly indicate the migration purpose**
- **NEVER use hash-based filenames (like `abc123_description.py`)**
- **NEVER use non-numerical prefixes or random strings**
- **ALWAYS check existing migration numbers before creating new ones**
- **ALWAYS rename any migration files that don't follow this pattern**

### Migration Revision ID Requirements
- **Revision IDs can be hash-based strings (e.g., 'c85d7af66778', '9002229c2a67')**
- **Revision IDs can be descriptive strings (e.g., 'consolidated_dive_system_final', 'add_parseddive_table_simple')**
- **Revision IDs can be any valid Alembic identifier including text strings**
- **Revision IDs are completely separate from filenames and can be any format**
- **Only the filename prefix must follow numerical ordering (0001_, 0002_, etc.)**
- **The actual revision ID in the file can be anything - hash, text, or descriptive string**

### Migration Revision ID Length Requirements
- **Revision IDs MUST fit within MySQL's VARCHAR(32) limit for the alembic_version.version_num column**
- **MySQL's default alembic_version table uses VARCHAR(32) for version_num column**
- **Revision IDs longer than 32 characters will cause "Data too long for column 'version_num'" errors**
- **When encountering length errors, shorten the revision ID rather than modifying database schema**
- **Keep revision IDs descriptive but concise (under 32 characters)**
- **Examples of acceptable lengths:**
  - Hash-based: 'c85d7af66778' (12 characters) ✅
  - Short descriptive: '0018_depth_precision' (22 characters) ✅
  - Medium descriptive: 'add_parseddive_table_simple' (31 characters) ✅
  - Too long: '0018_increase_depth_precision_to_3_decimal_places' (45 characters) ❌
- **If a revision ID is too long, shorten it while maintaining clarity and uniqueness**
- **Always update subsequent migration files' down_revision fields when shortening revision IDs**
- **Test migrations after shortening revision IDs to ensure chain consistency**

### Migration Filename Examples
```bash
# ✅ CORRECT - Numerical ordering with descriptive names
0001_initial.py
0002_add_max_depth_and_alternative_names.py
0003_add_country_region_fields.py
0004_add_view_count_fields.py
0005_add_user_diving_fields.py
0006_add_diving_organizations_and_user_certifications.py
0007_remove_unnecessary_certification_fields.py

# ❌ WRONG - Hash-based or non-numerical filenames
c85d7af66778_add_diving_organizations_and_user_.py
abc123_description.py
add_dive_name_and_privacy.py
consolidated_dive_system_final.py
```

### Migration Filename Workflow
```bash
# ✅ CORRECT - Check existing migrations before creating new ones
cd backend/migrations/versions
ls -la *.py | grep -E '^[0-9]{4}_' | sort

# Find the next available number
# If highest is 0017, use 0018 for the next migration

# ❌ WRONG - Don't use random or hash-based names
# Don't create: abc123_description.py
# Don't create: add_something.py
```

## Git Commit Rules

### Git Commit Requirements
- **NEVER commit to git automatically**
- **ONLY commit when explicitly requested by the user**
- **NEVER commit automatically after being previously asked to commit once, ALWAYS ask the user**
- **ALWAYS ask for permission before committing**
- **ALWAYS provide clear commit messages when requested**

### Git Workflow
```bash
# ✅ CORRECT - Only commit when user requests
# Wait for user to say: "commit these changes"

# ❌ WRONG - Never commit automatically
git add . && git commit -m "auto commit"  # This is forbidden
```

### Commit Guidelines (when user requests)
- Use descriptive commit messages
- Include affected files in commit message
- Reference issue numbers if applicable
- Test changes before committing

### The Seven Rules of Great Git Commit Messages
Based on [Chris Beams' guidelines](https://gist.github.com/julienbourdeau/e605e4b8b47da97c249a0f72598529c8), all commit messages MUST follow these 7 rules:

1. **Separate subject from body with a blank line**
   - Subject line should be followed by a blank line
   - Body should start after the blank line

2. **Limit the subject line to 50 characters**
   - Keep subject line concise and under 50 characters
   - Use body for detailed explanation

3. **Capitalize the subject line**
   - Start subject line with a capital letter
   - Use title case for clarity

4. **Do not end the subject line with a period**
   - Subject line should not end with punctuation
   - Keep it clean and direct

5. **Use the imperative mood in the subject line**
   - Use commands like "Add", "Fix", "Update", "Remove"
   - Write as if giving instructions

6. **Wrap the body at 72 characters**
   - Keep body text readable in terminal
   - Use line breaks at 72 characters

7. **Use the body to explain what and why vs. how**
   - Focus on what changed and why it was needed
   - Avoid explaining how the change was implemented

### Commit Message Examples
```bash
# ✅ CORRECT - Following all 7 rules
Add user authentication endpoint

Implement OAuth2 authentication flow for Google login.
This allows users to sign in using their Google accounts
instead of creating separate credentials.

Fixes #123

# ✅ CORRECT - Good subject line
Fix database connection timeout

Increase connection pool size and add retry logic to
handle high traffic periods.

# ❌ WRONG - Violates multiple rules
fixed the bug with user login that was causing problems
when users tried to log in with google accounts.

# ❌ WRONG - Subject too long, no blank line
Add comprehensive user authentication system with OAuth2 support for Google login and session management
```

### Commit Message Template
```bash
# Template to follow:
<imperative verb> <what was changed>

<Detailed explanation of what and why, wrapped at 72 characters>
<Additional context if needed>

<Optional: Fixes #issue_number>
<Optional: Related to #issue_number>
```

## Testing Requirements

### Test Environment Rules
- **ALWAYS run tests in virtual environments or within docker container**
- **NEVER run tests in system Python**
- **ALWAYS use project-specific test configurations**
- **ALWAYS use project's testing strategy document for guidance on testing**

### Backend Testing
```bash
# ✅ CORRECT - Use virtual environment for tests
cd backend
source divemap_venv/bin/activate
export PYTHONPATH="/home/kargig/src/divemap/backend/divemap_venv/lib/python3.11/site-packages:$PYTHONPATH"
python -m pytest tests/ -v

# ❌ WRONG - Never test in system Python
python -m pytest  # This is forbidden
```

### Frontend Testing
```bash
# ✅ CORRECT - Use Docker containers for frontend testing
docker exec divemap_frontend npm test
docker exec divemap_frontend node validate_frontend.js
docker exec divemap_frontend node test_regressions.js

# ❌ WRONG - Never run frontend commands on the system
npm test  # This is forbidden
node validate_frontend.js  # This is forbidden
node test_regressions.js  # This is forbidden
npx test  # This is forbidden
```

## Credentials

You will find credentials for various users in `local_testme` file. Use them when necessary

## Documentation Requirements

### Documentation Standards
- **ALWAYS use consistent markdown formatting**
- **ALWAYS include table of contents for files > 100 lines**
- **ALWAYS include clear problem statements**
- **ALWAYS provide step-by-step solutions**
- **ALWAYS document all affected files**
- **ALWAYS include troubleshooting sections**

### Documentation Organization
- **NEVER create documentation outside the docs/ directory**
- **ALWAYS organize documentation by category (getting-started, development, deployment, security, maintenance)**
- **ALWAYS update the main docs/README.md index when adding new documentation**
- **ALWAYS use existing file names if the changes fit their titles**
- **ONLY use new file names if the content and context is VERY different from existing files**

### Documentation Workflow
- **ALWAYS test documentation procedures before committing**
- **ALWAYS include code examples and screenshots where appropriate**
- **ALWAYS verify links and references**
- **ALWAYS update related documentation when making changes**

### Documentation Templates
```markdown
# [Title]

Brief description of what this document covers.

## Table of Contents

1. [Section 1](#section-1)
2. [Section 2](#section-2)
3. [Section 3](#section-3)

## Section 1

Content with clear explanations and examples.

### Subsection

Detailed information with code examples:

```bash
# Example command
command --option value
```

## Section 2

More content with proper formatting.

## Troubleshooting

Common issues and solutions.

## Related Documentation

- [Link to related doc 1](./related-doc-1.md)
- [Link to related doc 2](./related-doc-2.md)
```

### Documentation Quality Checklist
- [ ] All links work correctly
- [ ] Code examples are tested and functional
- [ ] Screenshots are up-to-date
- [ ] Table of contents is complete
- [ ] Related documentation is updated
- [ ] No broken references
- [ ] Consistent formatting throughout

## Development Workflow

### Docker Commands for Development
```bash
# Start all services
docker-compose up -d

# Stop all services
docker-compose down

# Run commands in containers
docker-compose exec divemap_frontend npm install package_name
docker-compose exec divemap_backend python -m pytest
docker-compose exec divemap_db mysql -u root -p

# Restart specific service
docker-compose restart divemap_frontend
docker-compose restart divemap_backend
docker-compose restart divemap_db
```

### Docker Logging Best Practices
```bash
# ✅ CORRECT - ALWAYS use docker logs for specific containers
# View all logs for a container:
docker logs divemap_frontend
docker logs divemap_backend
docker logs divemap_db

# View recent logs with --since flag (especially useful for debugging):
docker logs divemap_frontend --since 5m | tail -20
docker logs divemap_backend --since 10m | tail -20
docker logs divemap_db --since 1h | tail -20

# Filter logs for specific errors:
docker logs divemap_frontend --since 10m | grep -i "error\|warning"
docker logs divemap_backend --since 10m | grep -i "exception\|error"

# ❌ WRONG - NEVER use docker-compose logs
# docker-compose logs divemap_frontend  # This is forbidden
# docker-compose logs divemap_backend   # This is forbidden
# docker-compose logs divemap_db        # This is forbidden
```

### Environment Setup
1. Always activate virtual environment first
2. Set PYTHONPATH for asdf Python environments
3. Install packages only in virtual environment
4. Test in isolated environment

### Code Changes
1. Make changes in appropriate virtual environment
2. Test changes thoroughly
3. Ask user before committing
4. Provide clear documentation for changes

### Database Changes
1. Modify SQLAlchemy models
2. Generate Alembic migration
3. Review generated migration
4. **ALWAYS rename migration file to follow numerical ordering if needed**
5. **ALWAYS check existing migration numbers before creating new ones**
6. Test migration on development database
7. Apply migration only after testing

### Documentation Changes
1. Follow documentation standards
2. Use appropriate template
3. Update related documentation
4. Test all procedures
5. Update main documentation index

## Security Requirements

### Package Installation
- Never install packages globally
- Always verify package sources
- Use pinned versions in requirements.txt
- Regularly update dependencies

### Environment Variables
- Never commit secrets to git
- Use .env files for local development
- Use environment variables in production
- Validate environment configuration

## Documentation Requirements

### Code Documentation
- Document all new features
- Update README.md for user-facing changes
- Update API_CHANGELOG.md for API changes
- Update CHANGELOG.md for all changes

### Migration Documentation
- Document all database schema changes
- Include migration files in version control
- Provide rollback instructions
- Test migration procedures

### API Documentation
- Document all API endpoints
- Include request/response examples
- Document authentication requirements
- Provide error handling examples

### Deployment Documentation
- Document deployment procedures
- Include environment setup instructions
- Document troubleshooting steps
- Provide rollback procedures

## Error Handling

### Common Issues
- **ModuleNotFoundError**: Check PYTHONPATH and virtual environment
- **Database Connection**: Verify database is running and accessible
- **Migration Failures**: Check database state and migration history
- **Package Installation**: Ensure virtual environment is activated

### Troubleshooting Steps
1. Verify virtual environment is activated
2. Check PYTHONPATH for asdf environments
3. Ensure database is running
4. Check migration status with `alembic current`
5. Verify all dependencies are installed

## Compliance Checklist

Before making any changes, ensure:
- [ ] Virtual environment is activated (for backend development)
- [ ] PYTHONPATH is set correctly
- [ ] No system packages are being installed
- [ ] No npm/node commands are run on the system
- [ ] All frontend commands use Docker containers
- [ ] Alembic is used for database changes
- [ ] Migration filenames follow numerical ordering (0001_, 0002_, etc.)
- [ ] Tests run in virtual environment or Docker containers
- [ ] User permission obtained before git commits
- [ ] Commit messages follow the 7 rules of great git commits
- [ ] Documentation is updated
- [ ] Changes are tested thoroughly
- [ ] Documentation follows standards
- [ ] All links and references are verified
- [ ] No trailing whitespace in any files
- [ ] Code formatting is consistent
- [ ] Linting checks pass
- [ ] Whitespace validation passes
- [ ] JavaScript style rules are followed for frontend code

### Frontend-Specific Compliance
- [ ] Frontend container logs checked for ESLint errors
- [ ] ESLint validation passes in frontend container
- [ ] Import order follows project standards
- [ ] React hooks follow rules of hooks
- [ ] Prettier formatting is consistent
- [ ] No unused variables or imports
- [ ] Component prop types validated (where applicable)
- [ ] JavaScript style rules from `docs/development/javascript-style-rules.md` are followed

## Enforcement

These rules are mandatory and must be followed:
- Violations will result in immediate correction
- System package installations are strictly forbidden
- **Running npm, node, or frontend commands on the system is strictly forbidden**
- **All frontend development must use Docker containers**
- Manual database changes are not allowed
- Automatic git commits are prohibited
- All testing must use virtual environments or Docker containers
- All documentation must follow standards
- All migration filenames must follow numerical ordering
- Hash-based or non-numerical migration filenames are strictly forbidden
- **All commit messages must follow the 7 rules of great git commits**
- **Trailing whitespace is strictly forbidden**
- **All code must pass linting checks before committing**
- **All files must have consistent formatting**
- **All frontend changes must pass ESLint validation in container**
- **Frontend container logs must be checked for errors after file changes**

## Code Quality and Formatting Requirements

### Trailing Whitespace Prevention
- **NEVER create files with trailing whitespace**
- **ALWAYS remove trailing whitespace before committing**
- **ALWAYS run whitespace checks before committing**
- **ALWAYS use linting tools to catch whitespace issues**
- **NEVER leave trailing spaces or tabs at the end of lines**

### Code Formatting Standards
- **ALWAYS use consistent indentation (4 spaces for Python, 2 spaces for JavaScript)**
- **ALWAYS remove trailing whitespace from all lines**
- **ALWAYS ensure files end with a single newline**
- **ALWAYS use proper line endings (LF for Unix/Linux)**
- **NEVER use mixed tabs and spaces**

### Whitespace Checking Workflow
```bash
# ✅ CORRECT - Check for trailing whitespace before committing
# Check Python files
grep -r '[ \t]+$' --include="*.py" .

# Check JavaScript/JSX files
grep -r '[ \t]+$' --include="*.js" --include="*.jsx" .

# Check all text files
grep -r '[ \t]+$' --include="*.py" --include="*.js" --include="*.jsx" --include="*.md" --include="*.txt" .

# ❌ WRONG - Don't commit files with trailing whitespace
# Always clean whitespace before committing
```

### Automated Linting Setup
- **ALWAYS configure pre-commit hooks for whitespace checking**
- **ALWAYS use editor configurations to prevent trailing whitespace**
- **ALWAYS run linting as part of the testing process**
- **ALWAYS fix whitespace issues before running tests**

### Editor Configuration Requirements
- **ALWAYS configure editors to trim trailing whitespace on save**
- **ALWAYS configure editors to show whitespace characters**
- **ALWAYS use consistent line ending settings**
- **ALWAYS enable automatic formatting on save**

### Pre-commit Validation
```bash
# ✅ CORRECT - Validate code quality before committing
# Run whitespace check
./utils/check_whitespace.sh

# Run linting
./utils/lint_code.sh

# Run tests
./utils/run_tests.sh

# ❌ WRONG - Don't commit without validation
# Always run checks before committing
```

## Frontend Code Quality and ESLint Validation

### Frontend File Change Requirements
- **ALWAYS check frontend container logs for ESLint errors after making changes to frontend files**
- **ALWAYS run ESLint validation within the frontend container**
- **NEVER commit frontend changes without ESLint validation**
- **ALWAYS fix ESLint errors before considering changes complete**

### Frontend ESLint Validation Workflow
```bash
# ✅ CORRECT - Check frontend container logs for ESLint errors
# After making changes to frontend files, check container logs:
docker logs divemap_frontend | grep -i "eslint\|error\|warning"

# Or check recent logs with --since flag (more efficient):
docker logs divemap_frontend --since 5m | grep -i "eslint\|error\|warning"

# Or run ESLint directly in the frontend container:
docker-compose exec divemap_frontend npm run lint

# Check for specific file errors:
docker-compose exec divemap_frontend npm run lint -- --fix

# ❌ WRONG - Don't ignore ESLint errors in frontend container
# Always validate frontend code quality before proceeding
```

### Frontend Code Quality Standards
- **ALWAYS ensure all JavaScript/JSX files pass ESLint validation**
- **ALWAYS fix import order issues (import/order)**
- **ALWAYS fix React hooks rules violations (react-hooks/rules-of-hooks)**
- **ALWAYS fix Prettier formatting issues (prettier/prettier)**
- **ALWAYS remove trailing whitespace (no-trailing-spaces)**
- **ALWAYS fix unused variables and imports (no-unused-vars)**
- **ALWAYS validate prop types where applicable (react/prop-types)**
- **ALWAYS follow JavaScript style rules from `docs/development/javascript-style-rules.md`**

### Frontend Error Categories to Address
- **Critical**: ESLint errors that prevent compilation
- **High Priority**: React hooks rules violations
- **Medium Priority**: Import order and formatting issues
- **Low Priority**: Unused variables and prop type warnings

### Frontend Validation Checklist
Before considering frontend changes complete:
- [ ] ESLint validation passes in frontend container
- [ ] No critical ESLint errors in container logs
- [ ] Import order follows project standards
- [ ] React hooks follow rules of hooks
- [ ] Prettier formatting is consistent
- [ ] No trailing whitespace in files
- [ ] Unused variables and imports are cleaned up
- [ ] Component prop types are validated (where applicable)

Remember: **Always ask for permission before committing to git!**

## Chat Session Branch Management

### Branch Creation for Each Chat Session
- **ALWAYS create a new branch for each chat session when making code changes**
- **ALWAYS use descriptive branch names that reflect the chat session purpose**
- **ALWAYS create the branch from the current master/main branch**
- **NEVER work directly on master/main branch during chat sessions**

### Branch Naming Convention
```bash
# ✅ CORRECT - Descriptive branch names for chat sessions
feature/add-user-authentication
fix/database-connection-issues
enhancement/improve-frontend-performance
refactor/backend-api-structure

# ❌ WRONG - Generic or unclear branch names
chat-branch
temp-branch
fix-stuff
```

### Chat Session Workflow
1. **Create new branch at start of chat session**
   ```bash
   git checkout -b feature/descriptive-feature-name
   ```

2. **Make incremental commits after each batch of changes**
   - Commit changes after completing logical units of work
   - Use descriptive commit messages following the 7 rules
   - Each commit should represent a complete, testable change

3. **Continue development with multiple prompts**
   - Each prompt can request additional changes
   - Commit each batch of changes separately
   - Maintain clean commit history for easy review

4. **Final consolidation when user is satisfied**
   - Squash all commits into a single commit
   - Create comprehensive commit message covering all changes
   - Ask user if they want to create a pull request

### Commit Management During Chat Session
```bash
# ✅ CORRECT - Incremental commits during development
git add file1.js file2.js
git commit -m "Add user authentication components

Implement login form and authentication context.
Add form validation and error handling."

# Make more changes based on next prompt
git add file3.js file4.js
git commit -m "Add user profile management

Implement profile editing and avatar upload.
Add user preferences and settings."

# ❌ WRONG - Don't wait until end to commit
# Don't accumulate all changes in working directory
```

### Final Commit Consolidation
When the user indicates they are satisfied with all changes:

1. **Squash all commits into one**
   ```bash
   git reset --soft HEAD~N  # Where N is the number of commits to squash
   git commit -m "Comprehensive feature implementation

   This commit consolidates all changes from the chat session:
   - Add user authentication system
   - Implement profile management
   - Add form validation and error handling
   - Update documentation and tests
   
   All changes have been tested and validated."
   ```

2. **Ask user about pull request creation**
   - Confirm user is happy with the final consolidated commit
   - Offer to create a pull request to merge into master
   - Provide clear summary of what will be merged

### Pull Request Workflow
```bash
# ✅ CORRECT - Create pull request after user approval
git push origin feature/descriptive-feature-name

# Create pull request with:
# - Clear title describing the feature/fix
# - Detailed description of all changes
# - List of affected files and components
# - Testing instructions
# - Any breaking changes or considerations

# ❌ WRONG - Don't create PR without user approval
# Always confirm user wants to proceed with PR creation
```

### Chat Session Completion Checklist
Before considering a chat session complete:
- [ ] All requested changes have been implemented
- [ ] All changes have been tested and validated
- [ ] Code quality checks pass (linting, formatting, tests)
- [ ] All commits have been consolidated into one final commit
- [ ] User has confirmed they are satisfied with all changes
- [ ] User has approved creation of pull request
- [ ] Branch is ready for review and merging

### Branch Cleanup
After successful merge to master:
- **ALWAYS delete the feature branch locally and remotely**
- **ALWAYS ensure master branch is up to date**
- **ALWAYS verify all changes are properly merged**

```bash
# ✅ CORRECT - Clean up after successful merge
git checkout master
git pull origin master
git branch -d feature/descriptive-feature-name
git push origin --delete feature/descriptive-feature-name

# ❌ WRONG - Don't leave feature branches hanging
# Always clean up after successful merge
```
